/**
 * Server - HTTP and WebSocket server using Fastify.
 *
 * Serves the web client and handles WebSocket connections for the MUD.
 */

import Fastify, { type FastifyInstance } from 'fastify';
import fastifyStatic from '@fastify/static';
import fastifyWebsocket from '@fastify/websocket';
import { WebSocket } from 'ws';
import { join, resolve } from 'path';
import { readFile } from 'fs/promises';
import { Connection } from './connection.js';
import { ConnectionManager, getConnectionManager } from './connection-manager.js';
import { EventEmitter } from 'events';
import type { Logger } from 'pino';
import { getDriverVersion, getGameConfig } from '../driver/version.js';

/**
 * Server configuration.
 */
export interface ServerConfig {
  /** HTTP port */
  port: number;
  /** Bind address */
  host: string;
  /** Path to static client files */
  clientPath: string;
  /** Path to mudlib directory */
  mudlibPath: string;
  /** Logger instance */
  logger?: Logger;
  /** Enable HTTP request logging (default: false) */
  logHttpRequests?: boolean;
  /** WebSocket heartbeat interval in milliseconds (default: 45000) */
  wsHeartbeatIntervalMs?: number;
  /** Maximum missed pong responses before terminating connection (default: 2) */
  wsMaxMissedPongs?: number;
}

/**
 * Server events.
 */
export interface ServerEvents {
  connection: (connection: Connection) => void;
  disconnect: (connection: Connection, code: number, reason: string) => void;
  message: (connection: Connection, message: string) => void;
  error: (error: Error) => void;
}

/** Default heartbeat interval in milliseconds (45 seconds) */
const DEFAULT_HEARTBEAT_INTERVAL_MS = 45000;

/** Default maximum missed pong responses before terminating connection */
const DEFAULT_MAX_MISSED_PONGS = 2;

/**
 * MUD server handling HTTP and WebSocket connections.
 */
export class Server extends EventEmitter {
  private config: ServerConfig;
  private fastify: FastifyInstance;
  private connectionManager: ConnectionManager;
  private running: boolean = false;
  private heartbeatInterval: ReturnType<typeof setInterval> | null = null;
  private heartbeatIntervalMs: number;
  private maxMissedPongs: number;

  constructor(config: Partial<ServerConfig> = {}) {
    super();

    this.config = {
      port: config.port ?? 3000,
      host: config.host ?? '0.0.0.0',
      clientPath: config.clientPath ?? join(process.cwd(), 'dist', 'client'),
      mudlibPath: config.mudlibPath ?? join(process.cwd(), 'mudlib'),
      ...(config.logger ? { logger: config.logger } : {}),
    };

    // Initialize WebSocket heartbeat settings from config
    this.heartbeatIntervalMs = config.wsHeartbeatIntervalMs ?? DEFAULT_HEARTBEAT_INTERVAL_MS;
    this.maxMissedPongs = config.wsMaxMissedPongs ?? DEFAULT_MAX_MISSED_PONGS;

    this.connectionManager = getConnectionManager();

    // Create Fastify instance
    this.fastify = Fastify({
      logger: this.config.logger ? true : false,
      disableRequestLogging: !this.config.logHttpRequests,
    });
  }

  /**
   * Set up HTTP routes and WebSocket handler.
   */
  private async setupRoutes(): Promise<void> {
    // Register static file serving
    await this.fastify.register(fastifyStatic, {
      root: resolve(this.config.clientPath),
      prefix: '/',
    });

    // Register WebSocket support
    await this.fastify.register(fastifyWebsocket, {
      options: {
        maxPayload: 64 * 1024, // 64KB max message size
      },
    });

    // Health check endpoint
    this.fastify.get('/health', async () => {
      return {
        status: 'ok',
        uptime: process.uptime(),
        players: this.connectionManager.playerCount,
        connections: this.connectionManager.count,
      };
    });

    // Readiness check endpoint
    this.fastify.get('/ready', async () => {
      if (!this.running) {
        throw new Error('Server not ready');
      }
      return { status: 'ready' };
    });

    // Game/driver configuration endpoint (for client branding)
    this.fastify.get('/api/config', async () => {
      const game = getGameConfig();
      const driver = getDriverVersion();
      return {
        game: {
          name: game?.name ?? 'MudForge',
          tagline: game?.tagline ?? 'Your Adventure Awaits',
          version: game?.version ?? '1.0.0',
          description: game?.description ?? 'A Modern MUD Experience',
          establishedYear: game?.establishedYear ?? 2026,
          website: game?.website ?? 'https://www.mudforge.org',
        },
        driver: {
          name: driver.name,
          version: driver.version,
        },
      };
    });

    // Playable races endpoint (for registration)
    // Data is generated by the race daemon from mudlib/std/race/definitions.ts
    this.fastify.get('/api/races', async () => {
      try {
        const racesPath = resolve(this.config.mudlibPath, 'data', 'races.json');
        const content = await readFile(racesPath, 'utf-8');
        return JSON.parse(content);
      } catch {
        // Fallback if races.json doesn't exist yet (first startup)
        return [
          { id: 'human', name: 'Human', shortDescription: 'Versatile and adaptable', statBonuses: {}, abilities: [] }
        ];
      }
    });

    // Announcements endpoint (for login screen)
    this.fastify.get('/api/announcements', async () => {
      try {
        const announcementsPath = resolve(this.config.mudlibPath, 'data', 'announcements', 'announcements.json');
        const content = await readFile(announcementsPath, 'utf-8');
        const data = JSON.parse(content);
        // Sort by createdAt descending (newest first)
        const sorted = (data.announcements || []).sort(
          (a: { createdAt: number }, b: { createdAt: number }) => b.createdAt - a.createdAt
        );
        return {
          latest: sorted[0] || null,
          all: sorted,
        };
      } catch {
        // Fallback if announcements.json doesn't exist yet
        return {
          latest: null,
          all: [],
        };
      }
    });

    // WebSocket endpoint
    this.fastify.get('/ws', { websocket: true }, (socket: WebSocket, request) => {
      this.handleWebSocketConnection(socket, request);
    });
  }

  /**
   * Handle a new WebSocket connection.
   */
  private handleWebSocketConnection(socket: WebSocket, request: { ip?: string }): void {
    const id = this.connectionManager.generateId();
    const remoteAddress = request.ip || 'unknown';

    const connection = new Connection(socket, id, remoteAddress);
    this.connectionManager.add(connection);

    // Forward events
    connection.on('message', (message: string) => {
      this.emit('message', connection, message);
    });

    connection.on('close', (code: number, reason: string) => {
      this.emit('disconnect', connection, code, reason);
    });

    connection.on('error', (error: Error) => {
      this.emit('error', error);
    });

    // Emit connection event
    this.emit('connection', connection);
  }

  /**
   * Start the server.
   */
  async start(): Promise<void> {
    if (this.running) {
      return;
    }

    try {
      await this.setupRoutes();
      await this.fastify.listen({
        port: this.config.port,
        host: this.config.host,
      });

      this.running = true;
      this.startHeartbeat();
      console.log(`Server listening on ${this.config.host}:${this.config.port}`);
    } catch (error) {
      this.emit('error', error as Error);
      throw error;
    }
  }

  /**
   * Start the WebSocket heartbeat interval.
   * Sends ping frames to all connections periodically to keep them alive.
   * Allows up to maxMissedPongs missed responses before terminating.
   * Also sends data-frame keep-alives to satisfy load balancer idle timeouts.
   */
  private startHeartbeat(): void {
    this.heartbeatInterval = setInterval(() => {
      const connections = this.connectionManager.getAll();
      for (const connection of connections) {
        // Increment missed pongs counter before sending new ping
        const missedPongs = connection.incrementMissedPongs();

        if (missedPongs > this.maxMissedPongs) {
          // Connection has missed too many heartbeats - terminate it
          const metrics = connection.getHealthMetrics();
          this.config.logger?.warn(
            {
              id: connection.id,
              ...metrics,
            },
            'Connection terminated: missed too many heartbeats'
          );
          connection.terminate();
          continue;
        }

        // Send WebSocket ping frame (application-level heartbeat)
        connection.ping();

        // Also send a data-frame keep-alive message
        // This creates actual WebSocket data frames that load balancers/proxies
        // recognize as "activity", preventing idle connection timeouts
        connection.sendKeepAlive();
      }
    }, this.heartbeatIntervalMs);
  }

  /**
   * Stop the WebSocket heartbeat interval.
   */
  private stopHeartbeat(): void {
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
      this.heartbeatInterval = null;
    }
  }

  /**
   * Stop the server.
   */
  async stop(): Promise<void> {
    if (!this.running) {
      return;
    }

    // Stop heartbeat
    this.stopHeartbeat();

    // Close all connections
    this.connectionManager.closeAll(1001, 'Server shutting down');

    // Stop Fastify
    await this.fastify.close();

    this.running = false;
    console.log('Server stopped');
  }

  /**
   * Check if the server is running.
   */
  get isRunning(): boolean {
    return this.running;
  }

  /**
   * Get the connection manager.
   */
  getConnectionManager(): ConnectionManager {
    return this.connectionManager;
  }

  /**
   * Get the Fastify instance.
   */
  getFastify(): FastifyInstance {
    return this.fastify;
  }

  /**
   * Get the server port.
   */
  get port(): number {
    return this.config.port;
  }

  /**
   * Get the server host.
   */
  get host(): string {
    return this.config.host;
  }
}

export default Server;
